#!/usr/bin/env python3
""" CTypes wrapper module for interfacing with a Trace32 API. Wraps most of the
interesting functions documented in api_remote_c.pdf. Intended to be a
better-quality replacement for Lauterbach's `python-legacy` module, and also
their `python-rcl` module (which is missing a lot of functionality at the
time of this writing). """

import ctypes
import enum
import os
import re

from .t32api_errors import Errcode

# Errcode is auto-generated by parsing t32.h from the Trace32 CAPI. This assert
# is intended to verify that t32api_errors.py was created correctly.
assert len(Errcode) > 1

# --------------------------------------------------------------------------- #


class ApiError(Exception):
    """ Base exception class used to report failed Trace32 API calls. """

    def __init__(self, funcname, errcode):
        super().__init__()
        self.funcname = funcname

        if isinstance(errcode, Errcode):
            self.errcode = errcode
        else:
            matches = [x for x in Errcode if x == int(errcode)]

            if matches:
                self.errcode = matches[0]
            else:
                self.errcode = int(errcode)

    def __str__(self):
        err_msg = f"Function '{self.funcname}' returned nonzero status of "

        if isinstance(self.errcode, Errcode):
            err_msg += f"{self.errcode.value} ({self.errcode.name})."
        else:
            err_msg += str(self.errcode) + "."

        return err_msg


class CommunicationError(ApiError):
    """ Exception class used to report Trace32 API calls that failed
    because of communication errors between this library and the remote
    Trace32 instance. """


class CallFailure(ApiError):
    """ Exception class used to report Trace32 API calls that were sent
    successfully, but returned an error from the remote Trace32 instance. """


class CommandFailure(Exception):
    """ Exception class used to report that a PRACTICE command failed. Contains
    the failing command, and also some data about the error. """

    def __init__(self, command, error):
        super().__init__()
        self.command = command
        self.error = error

    def __str__(self):
        return self.error


class EvalError(Exception):
    """ Base exception class used to report failed Trace32 API calls. """

    def __init__(self, reason=None, expression=None):
        super().__init__()
        self.expression = expression
        self.reason = reason
        self.name = re.search("'.*'", str(self.__class__)).group(0)[1:-1]

    @staticmethod
    def _shorten(phrase):
        if phrase is None:
            return "None"
        clip = phrase[:32]
        if clip != phrase:
            clip += "..."
        return clip

    def __str__(self):
        expression = self._shorten(self.expression)

        if self.reason and self.expression:
            return f"[{expression}] ({self.reason})"

        if self.reason:
            return f"{self.reason}"

        if self.expression:
            return f"{expression}"

        return self.name

    def __repr__(self):
        result = self._shorten(self.reason)
        expression = self._shorten(self.expression)
        return f"{self.name}({result}, {expression})"


class AttachType(enum.IntEnum):
    """ Device-types understood by T32_Attach. Note that ICE is an alias for
    ICD. """
    OS = 0
    ICD = 1
    ICE = ICD


class MessageType(enum.IntEnum):
    """ Message types returned by T32_GetMessageString. """
    # pylint: disable = invalid-name
    Ignore = 0
    General_Info = 1
    Error = 2
    Status_Info = 8
    Error_Info = 16
    Temp_Display = 32
    Temp_Info = 64


class PracticeState(enum.IntEnum):
    """ Possible states for the remote's PRACTICE interpeter. """
    # pylint: disable = invalid-name
    Idle = 0
    Running = 1
    Dialog = 2


class ResultType(enum.IntEnum):
    """ Possible types of the result data from T32_ExecuteFunction. """
    # pylint: disable = invalid-name
    Boolean = 0x1
    Binary = 0x2
    Hexadecimal = 0x4
    Decimal = 0x8
    Float = 0x10
    ASCII = 0x20
    String = 0x40
    NumRange = 0x80
    Address = 0x100
    AddrRange = 0x200
    Time = 0x400
    TimeRange = 0x800
    BitMask = 0x4000
    Empty = 0x8000

# --------------------------------------------------------------------------- #


class StringConverter:
    """ Utility class intended to be used as a ctypes argtype. Stringifies
    anything that isn't a str, bytes, or bytearray instance. Converts the
    output to always be a 'bytes' instance, regardless of input. """
    # pylint: disable=too-few-public-methods

    @staticmethod
    def from_param(data):
        """ Converts 'data' to a bytes instance. Stringifies it first, if
        necessary. """

        if isinstance(data, bytearray):
            data = bytes(data)

        if not isinstance(data, bytes):
            data = str(data)

        if isinstance(data, str):
            data = data.encode('ascii')

        return ctypes.c_char_p(data)


def confirm_success(result, func, args=None):
    """ Confirms that the value of result is 0, and then returns it. Raises
    an error otherwise. Intended to commonize error-detection across all
    wrapped functions. """

    if int(result) == Errcode.OK:
        return Errcode(int(result))

    # Note on this: From api_remote_c.pdf, Lauterbach states that negative
    # values are reserved for communication/library errors, and positive
    # values are reserved for failed commands and the like.

    if int(result) in list(Errcode):
        errcode = Errcode(int(result))

        if errcode.value < 0:
            raise CommunicationError(func.__name__, errcode)
    else:
        errcode = int(result)

    arg_strings = []

    for arg in args:
        arg = repr(arg)
        if len(arg) > 64:
            arg = arg[0:64] + "..."

        arg_strings.append(arg)

    arg_str = "(%s)" % ", ".join(arg_strings)
    raise CallFailure(func.__name__ + arg_str, errcode)


# --------------------------------------------------------------------------- #


def _dll_init_generic(dll):
    """ Configure the basic ctypes wrappers of the "Generic API functions"
    imported from the Trace32 CAPI. Note only a subset is wrapped. """

    function_list = [
        'T32_Config', 'T32_Init', 'T32_Exit', 'T32_Attach',
        'T32_Nop', 'T32_Ping', 'T32_Cmd', 'T32_ExecuteCommand',
        'T32_ExecuteFunction', 'T32_Stop', 'T32_EvalGet', 'T32_EvalGetString',
        'T32_GetMessageString', 'T32_Terminate', 'T32_GetPracticeState',
        'T32_ResetCPU', 'T32_Break'
    ]

    for name in function_list:
        function = dll.__getattr__(name)
        function.argtypes = ()
        function.restype = ctypes.c_int
        function.errcheck = confirm_success

    dll.T32_Config.argtypes = (StringConverter, StringConverter)
    dll.T32_Attach.argtypes = (ctypes.c_int,)
    dll.T32_Cmd.argtypes = (StringConverter,)

    dll.T32_ExecuteCommand.argtypes = (
        StringConverter,
        ctypes.POINTER(ctypes.c_char),
        ctypes.c_uint32
    )

    dll.T32_ExecuteFunction.argtypes = (
        StringConverter,
        ctypes.POINTER(ctypes.c_char),
        ctypes.c_uint32,
        ctypes.POINTER(ctypes.c_uint32)
    )

    dll.T32_EvalGet.argtypes = (ctypes.POINTER(ctypes.c_uint32),)
    dll.T32_EvalGetString.argtypes = (ctypes.POINTER(ctypes.c_char),)

    dll.T32_GetMessageString.argtypes = (
        ctypes.POINTER(ctypes.c_char),
        ctypes.c_uint16,
        ctypes.POINTER(ctypes.c_uint16),
        ctypes.POINTER(ctypes.c_uint16)
    )

    dll.T32_Terminate.argtypes = (ctypes.c_int,)
    dll.T32_GetPracticeState.argtypes = (ctypes.POINTER(ctypes.c_int),)

    return dll


class Trace32API:
    """ Ctypes-based wrapper around useful Trace32 CAPI functions. Adds some
    argument management, standardized error-checking, etc. """
    # pylint: disable=invalid-name

    def __init__(self, libfile=None):
        if libfile is None:
            script_dir = os.path.abspath(os.path.dirname(__file__))
            libfile = os.path.join(
                script_dir,
                "_t32api.so"
            )

        libfile = os.path.abspath(libfile)
        self.dll = ctypes.cdll.LoadLibrary(libfile)
        self.dll = _dll_init_generic(self.dll)

        self.dll.read_memory.restype = ctypes.c_int
        self.dll.read_memory.errcheck = confirm_success
        self.dll.read_memory.argtypes = (
            ctypes.c_size_t,
            ctypes.c_uint8,
            ctypes.POINTER(ctypes.c_char),
            ctypes.c_int
        )

        self.dll.write_memory.argtypes = ()
        self.dll.write_memory.restype = ctypes.c_int
        self.dll.write_memory.errcheck = confirm_success
        self.dll.write_memory.argtypes = (
            ctypes.c_size_t,
            ctypes.c_uint8,
            ctypes.POINTER(ctypes.c_char),
            ctypes.c_int
        )

    def T32_Config(self, key, value):
        """ Sets $key to $value in the trace32 DLL. Used for setting up
        communication parameters before calling T32_Start(). Known parameters
        include: NODE, PACKLEN, PORT, TIMEOUT, HOSTPORT. """

        key = key.upper()

        if key.endswith("="):
            key = key[:-1]

        if key not in ('NODE', 'PACKLEN', 'PORT', 'TIMEOUT', 'HOSTPORT'):
            raise ValueError(f"Invalid key '{key}' for T32_Config")

        self.dll.T32_Config(key + '=', value)

    def T32_Init(self):
        """ Initializes the driver and connects to Trace32. Should be
        done before calling T32_Attach (which in-turn is necessary before
        doing anything useful). """

        self.dll.T32_Init()

    def T32_Attach(self, device=AttachType.ICD):
        """ Attaches to an initialized T32 session. Should be called
        immediately after T32_Init(). """

        if device not in (x.value for x in AttachType):
            raise ValueError(f"Invalid device '{device}' for T32_Attach")

        self.dll.T32_Attach(int(device))

    def T32_Exit(self):
        """ Terminates the connection to Trace32 instance. Doesn't actually
        exit any programs, despite the name. """

        self.dll.T32_Exit()

    def T32_Cmd(self, command):
        """ Runs a TRACE32 command on the connected instance. DO commands will
        return immediately, and all other kinds of commands will block until
        they're completed. """

        self.dll.T32_Cmd(command)

    def T32_Nop(self):
        """ Runs a NOP command that checks communication with the Trace32
        instance. See also: T32_Ping. """

        self.dll.T32_Nop()
        return True

    def T32_Ping(self):
        """ Runs a PING command that checks communication with the Trace32
        instance. See also: T32_Nop. """

        self.dll.T32_Ping()
        return True

    def T32_GetMessageString(self):
        """ Retrieves a message-string created by a PRACTICE command. Returns
        the string, as well as any type-hints associated with it."""

        msg_type = ctypes.c_uint16(0)
        msg_len = ctypes.c_uint16(0)
        buffer = ctypes.create_string_buffer(2**16)
        self.dll.T32_GetMessageString(buffer, 2**16 - 1, msg_type, msg_len)

        msg_type = msg_type.value
        msg_len = msg_len.value

        if msg_type == 0:
            return {"msg": "", "types": (MessageType(0),)}

        if buffer[msg_len - 1:msg_len] == b'\x00':
            msg_len -= 1

        # pylint: disable=consider-using-generator
        types = tuple([x for x in MessageType if int(x.value) & msg_type])
        msg = buffer.value.decode("ascii")
        return {"msg": msg, "types": types}

    def T32_EvalGet(self):
        """ Retrieves a exit-code from an EVAL or a few other specific PRACTICE
        commands. """

        result = ctypes.c_uint32(-1)
        self.dll.T32_EvalGet(result)
        return result.value

    def T32_EvalGetString(self):
        """ Retrieves a pending message from the global buffer used by a few
        specific PRACTICE commands such as EVAL. There is potentially some
        overlap with messages reported on T32_GetMessageString. """

        buffer = ctypes.create_string_buffer(2**16)
        self.dll.T32_EvalGetString(buffer)
        return buffer.value.decode("ascii")

    def T32_GetPracticeState(self):
        """ Checks to see whether a PRACTICE script is currently running. """

        pstate = ctypes.c_int(-1)
        self.dll.T32_GetPracticeState(pstate)

        if pstate.value == -1:
            raise CallFailure("T32_GetPracticeState.pstate", pstate)

        return PracticeState(pstate.value)

    def T32_Terminate(self, exit_code=0):
        """ Shuts down the remote Trace32 instance. Used for asking the remote
        trace32 to exit. """

        self.dll.T32_Terminate(exit_code)

    def T32_ExecuteCommand(self, cmd):
        """ Executes a TRACE32 command. Returns a buffer containing the
        response message (if any). DO commands will return immediately, and all
        other kinds of commands will block until they're completed. """

        buffer = ctypes.create_string_buffer(2**16)
        call_failure = None

        try:
            self.dll.T32_ExecuteCommand(cmd, buffer, 2**16 - 1)
        except CallFailure as err:
            call_failure = err

        if call_failure:
            if call_failure.errcode != Errcode.T32_ERR_EXECUTECOMMAND_FAIL:
                raise call_failure

            raise CommandFailure(cmd, buffer.value.decode("ascii"))

        return buffer.value.decode("ascii")

    def T32_ExecuteFunction(self, expression):
        """ Evaluate a TRACE32 expression/command. Return the resulting
        buffer, as well as its reported result-type. """

        buff = ctypes.create_string_buffer(2**16)
        restype = ctypes.c_uint32(0)
        error = False
        try:
            self.dll.T32_ExecuteFunction(expression, buff, 2**16 - 1, restype)
        except CallFailure:
            error = True

        if error:
            result = buff.value.decode('latin-1')
            raise EvalError(result, expression)

        if restype.value not in (x.value for x in ResultType):
            err_msg = f"result-type [{restype}] from T32_ExecuteFunction"
            err_msg += " is unknown."
            raise ValueError(err_msg)

        buff = buff.value.decode("ascii")
        return {"msg": buff, "type": ResultType(restype.value)}

    def T32_Stop(self):
        """ Stop a currently-running PRACTICE script. """

        self.dll.T32_Stop()

    def T32_ResetCPU(self):
        """ Reset the connected CPU. Effectively equivalent to running
        SYStem.UP and Register.RESet. """

        self.dll.T32_ResetCPU()

    def T32_Break(self):
        """ Break/halt the connected CPU.  """

        self.dll.T32_Break()
